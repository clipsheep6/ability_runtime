diff --git a/frameworks/js/napi/mission_manager/distributed_mission_manager.cpp b/frameworks/js/napi/mission_manager/distributed_mission_manager.cpp
index 2b27e118f..480c8c6ca 100644
--- a/frameworks/js/napi/mission_manager/distributed_mission_manager.cpp
+++ b/frameworks/js/napi/mission_manager/distributed_mission_manager.cpp
@@ -1208,10 +1208,18 @@ void ContinueAbilityExecuteCB(napi_env env, void *data)
         SetContinueAbilityCBRef(continueAbilityCB->abilityContinuationCB.callback[0]);
     HILOG_INFO("set callback success.");
     continueAbilityCB->result = -1;
-    continueAbilityCB->result = AAFwk::AbilityManagerClient::GetInstance()->
+    //
+    if (continueAbilityCB->hasArgsWithBundleName) {
+        continueAbilityCB->result = AAFwk::AbilityManagerClient::GetInstance()->
+        ContinueMission(continueAbilityCB->srcDeviceId, continueAbilityCB->dstDeviceId,
+        continueAbilityCB->bundleName, continueAbilityCB->abilityContinuation,
+        continueAbilityCB->wantParams);
+    } else {
+        continueAbilityCB->result = AAFwk::AbilityManagerClient::GetInstance()->
         ContinueMission(continueAbilityCB->srcDeviceId, continueAbilityCB->dstDeviceId,
         continueAbilityCB->missionId, continueAbilityCB->abilityContinuation,
         continueAbilityCB->wantParams);
+    }
     HILOG_INFO("%{public}s end. error:%{public}d ", __func__, continueAbilityCB->result);
 }
 
@@ -1295,6 +1303,22 @@ bool CheckContinueKeyExist(napi_env &env, const napi_value &value)
     return true;
 }
 
+bool CheckBundleNameExist(napi_env &env, const napi_value &value)
+{
+    bool isSrcDeviceId = false;
+    napi_has_named_property(env, value, "srcDeviceId", &isSrcDeviceId);
+    bool isDstDeviceId = false;
+    napi_has_named_property(env, value, "dstDeviceId", &isDstDeviceId);
+    bool isBundleName = false;
+    napi_has_named_property(env, value, "bundleName", &isBundleName);
+    bool isWantParam = false;
+    napi_has_named_property(env, value, "wantParam", &isWantParam);
+    if (!isSrcDeviceId && !isDstDeviceId && !isBundleName && !isWantParam) {
+        return false;
+    }
+    return true;
+}
+
 bool CheckContinueDeviceInfoSrcDeviceId(napi_env &env, napi_value &napiSrcDeviceId,
     ContinueAbilityCB *continueAbilityCB, std::string &errInfo)
 {
@@ -1337,6 +1361,20 @@ bool CheckContinueDeviceInfoMissionId(napi_env &env, napi_value &napiMissionId,
     return true;
 }
 
+bool CheckContinueDeviceInfoBundleName(napi_env &env, napi_value &napiBundleName,
+    ContinueAbilityCB *continueAbilityCB, std::string &errInfo)
+{
+    napi_valuetype valueType = napi_undefined;
+    napi_typeof(env, napiBundleName, &valueType);
+    if (valueType != napi_string) {
+        HILOG_ERROR("%{public}s, Wrong argument type missionId.", __func__);
+        errInfo = "Parameter error. The type of \"bundleName\" must be string";
+        return false;
+    }
+    continueAbilityCB->bundleName = AppExecFwk::UnwrapStringFromJS(env, napiBundleName, "");
+    return true;
+}
+
 bool CheckContinueDeviceInfoWantParam(napi_env &env, napi_value &napiWantParam,
     ContinueAbilityCB *continueAbilityCB, std::string &errInfo)
 {
@@ -1355,7 +1393,7 @@ bool CheckContinueDeviceInfoWantParam(napi_env &env, napi_value &napiWantParam,
     return true;
 }
 
-bool CheckContinueFirstArgs(napi_env &env, const napi_value &value,
+bool CheckArgsWithMissionId(napi_env &env, const napi_value &value,
     ContinueAbilityCB *continueAbilityCB, std::string &errInfo)
 {
     HILOG_INFO("%{public}s called.", __func__);
@@ -1398,6 +1436,45 @@ bool CheckContinueFirstArgs(napi_env &env, const napi_value &value,
     return true;
 }
 
+bool CheckArgsWithBundleName(napi_env &env, const napi_value &value,
+    ContinueAbilityCB *continueAbilityCB, std::string &errInfo)
+{
+    HILOG_INFO("%{public}s called.", __func__);
+    if (!CheckBundleNameExist(env, value)) {
+        HILOG_ERROR("%{public}s, Args without bundleName.", __func__);
+        return false;
+    }
+    napi_value napiSrcDeviceId = nullptr;
+    napi_value napiDstDeviceId = nullptr;
+    napi_value napiBundleName = nullptr;
+    napi_value napiWantParam = nullptr;
+    napi_valuetype valueType = napi_undefined;
+    napi_typeof(env, value, &valueType);
+    if (valueType != napi_object) {
+        HILOG_ERROR("%{public}s, Args without bundleName.", __func__);
+        return false;
+    }
+    napi_get_named_property(env, value, "srcDeviceId", &napiSrcDeviceId);
+    napi_get_named_property(env, value, "dstDeviceId", &napiDstDeviceId);
+    napi_get_named_property(env, value, "bundleName", &napiBundleName);
+    napi_get_named_property(env, value, "wantParam", &napiWantParam);
+    if (napiSrcDeviceId == nullptr || napiDstDeviceId == nullptr ||
+        napiBundleName == nullptr || napiWantParam == nullptr) {
+        HILOG_ERROR("%{public}s, miss required parameters.", __func__);
+        return false;
+    }
+
+    if (!CheckContinueDeviceInfoSrcDeviceId(env, napiSrcDeviceId, continueAbilityCB, errInfo) ||
+        !CheckContinueDeviceInfoDstDeviceId(env, napiDstDeviceId, continueAbilityCB, errInfo) ||
+        !CheckContinueDeviceInfoBundleName(env, napiBundleName, continueAbilityCB, errInfo) ||
+        !CheckContinueDeviceInfoWantParam(env, napiWantParam, continueAbilityCB, errInfo)) {
+        HILOG_ERROR("%{public}s, continueMission check ContinueDeviceInfo value failed.", __func__);
+        return false;
+    }
+    HILOG_INFO("%{public}s called end.", __func__);
+    return true;
+}
+
 bool CheckContinueCallback(napi_env &env, const napi_value &value,
     ContinueAbilityCB *continueAbilityCB, std::string &errInfo)
 {
@@ -1434,6 +1511,18 @@ bool CheckContinueCallback(napi_env &env, const napi_value &value,
     return true;
 }
 
+bool CheckContinueCallbackWithBundleName(napi_env &env, const napi_value &value,
+    ContinueAbilityCB *continueAbilityCB, std::string &errInfo)
+{
+    napi_valuetype valueType = napi_undefined;
+    napi_typeof(env, value, &valueType);
+    if (valueType != napi_function) {
+        return false;
+    }
+    napi_create_reference(env, value, 1, &continueAbilityCB->callbackRef);
+    return true;
+}
+
 napi_value ContinueAbilityWrap(napi_env &env, napi_callback_info info,
     ContinueAbilityCB *continueAbilityCB, std::string &errInfo)
 {
@@ -1444,33 +1533,48 @@ napi_value ContinueAbilityWrap(napi_env &env, napi_callback_info info,
 
     napi_get_cb_info(env, info, &argcAsync, args, nullptr, nullptr);
     HILOG_INFO("argcAsync is %{public}zu", argcAsync);
-    if (argcAsync != ARGS_TWO && argcAsync != ARGS_THREE) {
+
+    if (argcAsync != ARGS_ONE && argcAsync != ARGS_TWO && argcAsync != ARGS_THREE) {
         HILOG_ERROR("%{public}s, Wrong argument count.", __func__);
-        errInfo = "Parameter error. The type of \"number of parameters\" must be 2 or 3";
+        errInfo = "Parameter error. The type of \"number of parameters\" must be 1 or 2 or 3";
         return nullptr;
     }
 
-    if (!CheckContinueFirstArgs(env, args[0], continueAbilityCB, errInfo)) {
-        HILOG_ERROR("%{public}s, check the first argument failed.", __func__);
-        return nullptr;
+    //
+    if (CheckArgsWithBundleName(env, args[0], continueAbilityCB, errInfo)) {
+        continueAbilityCB->hasArgsWithBundleName = true;
+        if (argcAsync == ARGS_TWO &&CheckContinueCallbackWithBundleName(env, args[1], continueAbilityCB, errInfo))
+        {
+            ret = ContinueAbilityAsync(env, continueAbilityCB);
+            HILOG_INFO("%{public}s called end.", __func__);
+            return ret;
+        }
     }
+    //
 
-    if (argcAsync > 1) {
-        if (!CheckContinueCallback(env, args[1], continueAbilityCB, errInfo)) {
-            HILOG_ERROR("%{public}s, check callback failed.", __func__);
+    if (!continueAbilityCB->hasArgsWithBundleName) {
+        if (!CheckArgsWithMissionId(env, args[0], continueAbilityCB, errInfo)) {
+            HILOG_ERROR("%{public}s, check the first argument failed.", __func__);
             return nullptr;
         }
-    }
 
-    if (argcAsync == ARGS_THREE) {
-        napi_valuetype valueType = napi_undefined;
-        napi_typeof(env, args[ARGS_TWO], &valueType);
-        if (valueType != napi_function) {
-            HILOG_ERROR("%{public}s, callback error type.", __func__);
-            errInfo = "Parameter error. The type of \"callback\" must be AsynCallback<void>: void";
-            return nullptr;
+        if (argcAsync > 1) {
+            if (!CheckContinueCallback(env, args[1], continueAbilityCB, errInfo)) {
+                HILOG_ERROR("%{public}s, check callback failed.", __func__);
+                return nullptr;
+            }
+        }
+
+        if (argcAsync == ARGS_THREE) {
+            napi_valuetype valueType = napi_undefined;
+            napi_typeof(env, args[ARGS_TWO], &valueType);
+            if (valueType != napi_function) {
+                HILOG_ERROR("%{public}s, callback error type.", __func__);
+                errInfo = "Parameter error. The type of \"callback\" must be AsynCallback<void>: void";
+                return nullptr;
+            }
+            napi_create_reference(env, args[ARGS_TWO], 1, &continueAbilityCB->callbackRef);
         }
-        napi_create_reference(env, args[ARGS_TWO], 1, &continueAbilityCB->callbackRef);
     }
 
     ret = ContinueAbilityAsync(env, continueAbilityCB);
diff --git a/frameworks/js/napi/mission_manager/distributed_mission_manager.h b/frameworks/js/napi/mission_manager/distributed_mission_manager.h
index 2ad592e70..86dd0a63a 100644
--- a/frameworks/js/napi/mission_manager/distributed_mission_manager.h
+++ b/frameworks/js/napi/mission_manager/distributed_mission_manager.h
@@ -114,6 +114,8 @@ struct ContinueAbilityCB {
     ErrCode result = 0;
     int resultCode = 0;
     int missionId = 0;
+    std::string bundleName;
+    bool hasArgsWithBundleName = false;
     napi_ref callbackRef;
 };
 
diff --git a/frameworks/native/ability/native/distributed_ability_runtime/distributed_client.cpp b/frameworks/native/ability/native/distributed_ability_runtime/distributed_client.cpp
index 3909bd01e..e187ae98b 100644
--- a/frameworks/native/ability/native/distributed_ability_runtime/distributed_client.cpp
+++ b/frameworks/native/ability/native/distributed_ability_runtime/distributed_client.cpp
@@ -129,6 +129,32 @@ int32_t DistributedClient::ContinueMission(const std::string& srcDeviceId, const
     PARCEL_TRANSACT_SYNC_RET_INT(remote, CONTINUE_MISSION, data, reply);
 }
 
+int32_t DistributedClient::ContinueMission(const std::string& srcDeviceId, const std::string& dstDeviceId,
+    const std::string& bundleName, const sptr<IRemoteObject>& callback, const OHOS::AAFwk::WantParams& wantParams)
+{
+    HILOG_INFO("called");
+    if (callback == nullptr) {
+        HILOG_ERROR("ContinueMission callback null");
+        return ERR_NULL_OBJECT;
+    }
+    sptr<IRemoteObject> remote = GetDmsProxy();
+    if (remote == nullptr) {
+        HILOG_ERROR("ContinueMission remote service null");
+        return INVALID_PARAMETERS_ERR;
+    }
+    MessageParcel data;
+    if (!data.WriteInterfaceToken(DMS_PROXY_INTERFACE_TOKEN)) {
+        return ERR_FLATTEN_OBJECT;
+    }
+    PARCEL_WRITE_HELPER(data, String, srcDeviceId);
+    PARCEL_WRITE_HELPER(data, String, dstDeviceId);
+    PARCEL_WRITE_HELPER(data, String, bundleName);
+    PARCEL_WRITE_HELPER(data, RemoteObject, callback);
+    PARCEL_WRITE_HELPER(data, Parcelable, &wantParams);
+    MessageParcel reply;
+    PARCEL_TRANSACT_SYNC_RET_INT(remote, CONTINUE_MISSION_OF_BUNDLENAME, data, reply);
+}
+
 int32_t DistributedClient::StartContinuation(const OHOS::AAFwk::Want& want, int32_t missionId, int32_t callerUid,
     int32_t status, uint32_t accessToken)
 {
diff --git a/interfaces/inner_api/ability_manager/include/ability_manager_client.h b/interfaces/inner_api/ability_manager/include/ability_manager_client.h
index 33e9e91b6..8002ddfd3 100644
--- a/interfaces/inner_api/ability_manager/include/ability_manager_client.h
+++ b/interfaces/inner_api/ability_manager/include/ability_manager_client.h
@@ -479,6 +479,19 @@ public:
     ErrCode ContinueMission(const std::string &srcDeviceId, const std::string &dstDeviceId, int32_t missionId,
         const sptr<IRemoteObject> &callback, AAFwk::WantParams &wantParams);
 
+    /**
+     * ContinueMission, continue ability from mission center.
+     *
+     * @param srcDeviceId, origin deviceId.
+     * @param dstDeviceId, target deviceId.
+     * @param bundleName, indicates which bundleName to continue.
+     * @param callBack, notify result back.
+     * @param wantParams, extended params.
+     * @return Returns ERR_OK on success, others on failure.
+     */
+    ErrCode ContinueMission(const std::string &srcDeviceId, const std::string &dstDeviceId,
+        const std::string &bundleName, const sptr<IRemoteObject> &callback, AAFwk::WantParams &wantParams);
+
     /**
      * start continuation.
      * @param want, used to start a ability.
diff --git a/interfaces/inner_api/ability_manager/include/ability_manager_interface.h b/interfaces/inner_api/ability_manager/include/ability_manager_interface.h
index 7c84e7fc8..8771bc8c7 100644
--- a/interfaces/inner_api/ability_manager/include/ability_manager_interface.h
+++ b/interfaces/inner_api/ability_manager/include/ability_manager_interface.h
@@ -569,6 +569,9 @@ public:
     virtual int ContinueMission(const std::string &srcDeviceId, const std::string &dstDeviceId, int32_t missionId,
         const sptr<IRemoteObject> &callBack, AAFwk::WantParams &wantParams) = 0;
 
+    virtual int ContinueMission(const std::string &srcDeviceId, const std::string &dstDeviceId,
+        const std::string &bundleName, const sptr<IRemoteObject> &callBack, AAFwk::WantParams &wantParams) = 0;
+
     virtual int ContinueAbility(const std::string &deviceId, int32_t missionId, uint32_t versionCode) = 0;
 
     virtual int StartContinuation(const Want &want, const sptr<IRemoteObject> &abilityToken, int32_t status) = 0;
@@ -1219,6 +1222,8 @@ public:
 
         SEND_RESULT_TO_ABILITY = 1106,
 
+        CONTINUE_MISSION_OF_BUNDLENAME = 1107,
+
         // ipc id for mission manager(1110)
         REGISTER_REMOTE_MISSION_LISTENER = 1110,
         UNREGISTER_REMOTE_MISSION_LISTENER = 1111,
diff --git a/interfaces/kits/native/ability/native/distributed_ability_runtime/distributed_client.h b/interfaces/kits/native/ability/native/distributed_ability_runtime/distributed_client.h
index df8882978..826b4438f 100644
--- a/interfaces/kits/native/ability/native/distributed_ability_runtime/distributed_client.h
+++ b/interfaces/kits/native/ability/native/distributed_ability_runtime/distributed_client.h
@@ -35,6 +35,8 @@ public:
         uint32_t accessToken);
     int32_t ContinueMission(const std::string& srcDeviceId, const std::string& dstDeviceId,
         int32_t missionId, const sptr<IRemoteObject>& callback, const OHOS::AAFwk::WantParams& wantParams);
+    int32_t ContinueMission(const std::string& srcDeviceId, const std::string& dstDeviceId,
+        const std::string&  bundleName, const sptr<IRemoteObject>& callback, const OHOS::AAFwk::WantParams& wantParams);
     int32_t StartContinuation(const OHOS::AAFwk::Want& want, int32_t missionId, int32_t callerUid,
         int32_t status, uint32_t accessToken);
     int32_t NotifyCompleteContinuation(const std::u16string &devId, int32_t sessionId, bool isSuccess);
@@ -61,6 +63,7 @@ public:
         START_CONTINUATION = 11,
         NOTIFY_COMPLETE_CONTINUATION = 12,
         CONTINUE_MISSION = 36,
+        CONTINUE_MISSION_OF_BUNDLENAME = 37,
         GET_MISSION_INFOS = 80,
         REGISTER_MISSION_LISTENER = 84,
         UNREGISTER_MISSION_LISTENER = 85,
diff --git a/services/abilitymgr/include/ability_manager_proxy.h b/services/abilitymgr/include/ability_manager_proxy.h
index c8fee41f6..a424e273b 100644
--- a/services/abilitymgr/include/ability_manager_proxy.h
+++ b/services/abilitymgr/include/ability_manager_proxy.h
@@ -480,6 +480,9 @@ public:
     virtual int ContinueMission(const std::string &srcDeviceId, const std::string &dstDeviceId,
         int32_t missionId, const sptr<IRemoteObject> &callBack, AAFwk::WantParams &wantParams) override;
 
+    virtual int ContinueMission(const std::string &srcDeviceId, const std::string &dstDeviceId,
+        const std::string &bundleName, const sptr<IRemoteObject> &callBack, AAFwk::WantParams &wantParams) override;
+
     virtual int ContinueAbility(const std::string &deviceId, int32_t missionId, uint32_t versionCode) override;
 
     virtual int StartContinuation(const Want &want, const sptr<IRemoteObject> &abilityToken, int32_t status) override;
diff --git a/services/abilitymgr/include/ability_manager_service.h b/services/abilitymgr/include/ability_manager_service.h
index a81e6bfa4..77744ffbf 100644
--- a/services/abilitymgr/include/ability_manager_service.h
+++ b/services/abilitymgr/include/ability_manager_service.h
@@ -360,6 +360,19 @@ public:
     virtual int ContinueMission(const std::string &srcDeviceId, const std::string &dstDeviceId,
         int32_t missionId, const sptr<IRemoteObject> &callBack, AAFwk::WantParams &wantParams) override;
 
+    /**
+     * ContinueMission, continue ability from mission center.
+     *
+     * @param srcDeviceId, origin deviceId.
+     * @param dstDeviceId, target deviceId.
+     * @param bundleName, indicates which ability to continue.
+     * @param callBack, notify result back.
+     * @param wantParams, extended params.
+     * @return Returns ERR_OK on success, others on failure.
+     */
+    virtual int ContinueMission(const std::string &srcDeviceId, const std::string &dstDeviceId,
+        const std::string &bundleName, const sptr<IRemoteObject> &callBack, AAFwk::WantParams &wantParams) override;
+
     /**
      * ContinueAbility, continue ability to ability.
      *
diff --git a/services/abilitymgr/include/ability_manager_stub.h b/services/abilitymgr/include/ability_manager_stub.h
index f22f8f50e..9ba3a07ad 100644
--- a/services/abilitymgr/include/ability_manager_stub.h
+++ b/services/abilitymgr/include/ability_manager_stub.h
@@ -124,6 +124,7 @@ private:
     int ClearUpApplicationDataInner(MessageParcel &data, MessageParcel &reply);
 
     int ContinueMissionInner(MessageParcel &data, MessageParcel &reply);
+    int ContinueMissionOfBundleNameInner(MessageParcel &data, MessageParcel &reply);
     int ContinueAbilityInner(MessageParcel &data, MessageParcel &reply);
     int StartContinuationInner(MessageParcel &data, MessageParcel &reply);
     int NotifyCompleteContinuationInner(MessageParcel &data, MessageParcel &reply);
diff --git a/services/abilitymgr/src/ability_manager_client.cpp b/services/abilitymgr/src/ability_manager_client.cpp
index ecfe14f88..fed6426a7 100644
--- a/services/abilitymgr/src/ability_manager_client.cpp
+++ b/services/abilitymgr/src/ability_manager_client.cpp
@@ -501,6 +501,20 @@ ErrCode AbilityManagerClient::ContinueMission(const std::string &srcDeviceId, co
     return result;
 }
 
+ErrCode AbilityManagerClient::ContinueMission(const std::string &srcDeviceId, const std::string &dstDeviceId,
+    const std::string &bundleName, const sptr<IRemoteObject> &callback, AAFwk::WantParams &wantParams)
+{
+    if (srcDeviceId.empty() || dstDeviceId.empty() || callback == nullptr) {
+        HILOG_ERROR("srcDeviceId or dstDeviceId or callback is null!");
+        return ERR_INVALID_VALUE;
+    }
+
+    auto abms = GetAbilityManager();
+    CHECK_POINTER_RETURN_NOT_CONNECTED(abms);
+    int result = abms->ContinueMission(srcDeviceId, dstDeviceId, bundleName, callback, wantParams);
+    return result;
+}
+
 ErrCode AbilityManagerClient::StartContinuation(const Want &want, const sptr<IRemoteObject> &abilityToken,
     int32_t status)
 {
diff --git a/services/abilitymgr/src/ability_manager_proxy.cpp b/services/abilitymgr/src/ability_manager_proxy.cpp
index 4455f9747..d16e3a689 100644
--- a/services/abilitymgr/src/ability_manager_proxy.cpp
+++ b/services/abilitymgr/src/ability_manager_proxy.cpp
@@ -2085,6 +2085,49 @@ int AbilityManagerProxy::ContinueMission(const std::string &srcDeviceId, const s
     return reply.ReadInt32();
 }
 
+int AbilityManagerProxy::ContinueMission(const std::string &srcDeviceId, const std::string &dstDeviceId,
+    const std::string &bundleName, const sptr<IRemoteObject> &callBack, AAFwk::WantParams &wantParams)
+{
+    MessageParcel data;
+    MessageParcel reply;
+    MessageOption option;
+    if (!WriteInterfaceToken(data)) {
+        return INNER_ERR;
+    }
+    if (!data.WriteString(srcDeviceId)) {
+        HILOG_ERROR("srcDeviceId write failed.");
+        return INNER_ERR;
+    }
+    if (!data.WriteString(dstDeviceId)) {
+        HILOG_ERROR("dstDeviceId write failed.");
+        return INNER_ERR;
+    }
+    if (!data.WriteString(bundleName)) {
+        HILOG_ERROR("missionId write failed.");
+        return INNER_ERR;
+    }
+    if (!data.WriteRemoteObject(callBack)) {
+        HILOG_ERROR("callBack write failed.");
+        return INNER_ERR;
+    }
+    if (!data.WriteParcelable(&wantParams)) {
+        HILOG_ERROR("wantParams write failed.");
+        return INNER_ERR;
+    }
+
+    sptr<IRemoteObject> remote = Remote();
+    if (remote == nullptr) {
+        HILOG_ERROR("Remote() is NULL");
+        return INNER_ERR;
+    }
+    auto error = remote->SendRequest(IAbilityManager::CONTINUE_MISSION_OF_BUNDLENAME, data, reply, option);
+    if (error != NO_ERROR) {
+        HILOG_ERROR("Send request error: %{public}d", error);
+        return error;
+    }
+    return reply.ReadInt32();
+}
+
 int AbilityManagerProxy::ContinueAbility(const std::string &deviceId, int32_t missionId, uint32_t versionCode)
 {
     MessageParcel data;
diff --git a/services/abilitymgr/src/ability_manager_service.cpp b/services/abilitymgr/src/ability_manager_service.cpp
index 294bb4f86..07d87187e 100644
--- a/services/abilitymgr/src/ability_manager_service.cpp
+++ b/services/abilitymgr/src/ability_manager_service.cpp
@@ -2302,6 +2302,18 @@ int AbilityManagerService::ContinueMission(const std::string &srcDeviceId, const
     return dmsClient.ContinueMission(srcDeviceId, dstDeviceId, missionId, callBack, wantParams);
 }
 
+int AbilityManagerService::ContinueMission(const std::string &srcDeviceId, const std::string &dstDeviceId,
+    const std::string &bundleName, const sptr<IRemoteObject> &callBack, AAFwk::WantParams &wantParams)
+{
+    if (!PermissionVerification::GetInstance()->VerifyMissionPermission()) {
+        HILOG_ERROR("%{public}s: Permission verification failed", __func__);
+        return CHECK_PERMISSION_FAILED;
+    }
+
+    DistributedClient dmsClient;
+    return dmsClient.ContinueMission(srcDeviceId, dstDeviceId, bundleName, callBack, wantParams);
+}
+
 int AbilityManagerService::ContinueAbility(const std::string &deviceId, int32_t missionId, uint32_t versionCode)
 {
     HILOG_INFO("ContinueAbility missionId = %{public}d, version = %{public}u.", missionId, versionCode);
diff --git a/services/abilitymgr/src/ability_manager_stub.cpp b/services/abilitymgr/src/ability_manager_stub.cpp
index 073018c3d..9aa9cf2b6 100644
--- a/services/abilitymgr/src/ability_manager_stub.cpp
+++ b/services/abilitymgr/src/ability_manager_stub.cpp
@@ -65,6 +65,7 @@ void AbilityManagerStub::FirstStepInit()
     requestFuncMap_[DUMPSYS_STATE] = &AbilityManagerStub::DumpSysStateInner;
     requestFuncMap_[START_ABILITY_FOR_SETTINGS] = &AbilityManagerStub::StartAbilityForSettingsInner;
     requestFuncMap_[CONTINUE_MISSION] = &AbilityManagerStub::ContinueMissionInner;
+    requestFuncMap_[CONTINUE_MISSION_OF_BUNDLENAME] = &AbilityManagerStub::ContinueMissionOfBundleNameInner;
     requestFuncMap_[CONTINUE_ABILITY] = &AbilityManagerStub::ContinueAbilityInner;
     requestFuncMap_[START_CONTINUATION] = &AbilityManagerStub::StartContinuationInner;
     requestFuncMap_[NOTIFY_COMPLETE_CONTINUATION] = &AbilityManagerStub::NotifyCompleteContinuationInner;
@@ -993,6 +994,26 @@ int AbilityManagerStub::ContinueMissionInner(MessageParcel &data, MessageParcel
     return result;
 }
 
+int AbilityManagerStub::ContinueMissionOfBundleNameInner(MessageParcel &data, MessageParcel &reply)
+{
+    std::string srcDeviceId = data.ReadString();
+    std::string dstDeviceId = data.ReadString();
+    std::string bundleName = data.ReadString();
+    sptr<IRemoteObject> callback = data.ReadRemoteObject();
+    if (callback == nullptr) {
+        HILOG_ERROR("ContinueMissionInner callback readParcelable failed!");
+        return ERR_NULL_OBJECT;
+    }
+    std::unique_ptr<WantParams> wantParams(data.ReadParcelable<WantParams>());
+    if (wantParams == nullptr) {
+        HILOG_ERROR("ContinueMissionInner wantParams readParcelable failed!");
+        return ERR_NULL_OBJECT;
+    }
+    int32_t result = ContinueMission(srcDeviceId, dstDeviceId, bundleName, callback, *wantParams);
+    HILOG_INFO("ContinueMissionInner result = %{public}d", result);
+    return result;
+}
+
 int AbilityManagerStub::ContinueAbilityInner(MessageParcel &data, MessageParcel &reply)
 {
     std::string deviceId = data.ReadString();
